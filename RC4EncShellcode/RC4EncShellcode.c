//Just executes the input raw data and prints the shellcode without executing
#include <Windows.h>
#include <stdio.h>

// Defining a USTRING struct
// This is what SystemFunction032 function take as parameters
typedef struct
{
	DWORD	Length;
	DWORD	MaximumLength;
	PVOID	Buffer;

} USTRING;

// Defining how does the SystemFunction032 function look. 
// More on this structure in the API Hashing module5
typedef NTSTATUS(NTAPI* fnSystemFunction032)(
	struct USTRING* Img,
	struct USTRING* Key
	);

//PBYTE: Basically is Pointer to BYTE which points binary buffers
//DWORD: Double Word
BOOL Rc4EncryptionViSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

	// The return of SystemFunction032
	NTSTATUS	STATUS = NULL;

	// Making 2 USTRING variables
	// 1 is passed as the key and the other one is passed as the block of data to encrypt/decrypt
	USTRING		Key = { .Buffer = pRc4Key, 			.Length = dwRc4KeySize,		.MaximumLength = dwRc4KeySize },
			Img = { .Buffer = pPayloadData, 		.Length = sPayloadSize,		.MaximumLength = sPayloadSize };


	// Since SystemFunction032 is exported from Advapi32.dll, use LoadLibraryA to load Advapi32.dll into the process, 
	// And use LoadLibraryA's return value as the hModule parameter in GetProcAddress
	fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

	// If the SystemFunction032 invocation failed, it will return a non-zero value 
	if ((STATUS = SystemFunction032(&Img, &Key)) != 0x0) {
		printf("[!] SystemFunction032 FAILED With Error: 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}

// Print the input buffer as a hex char array
// LPCSTR: Long Pointer to Constant ANSI STRing.
VOID PrintHexData(LPCSTR Name, PBYTE Data, SIZE_T Size) {

	printf("unsigned char %s[] = {", Name);//starts array declaration without signing

	for (int i = 0; i < Size; i++) {
		if (i % 16 == 0) {
			printf("\n\t");
		}
		if (i < Size - 1) {
			printf("0x%0.2X, ", Data[i]);
		}
		else {
			printf("0x%0.2X ", Data[i]);
		}
	}

	printf("};\n\n\n");// closes array declaration without signing

}

// Encrypted msfvenom x64 calc shellcode 
unsigned char EncShellcode[] = {
		0x15, 0xD4, 0xC3, 0x1D, 0xB7, 0x0A, 0xD9, 0xCC, 0x06, 0xDB, 0xD6, 0x97, 0x4F, 0x8D, 0x78, 0x1E,
		0x85, 0x39, 0xB0, 0x8D, 0x97, 0xFF, 0xC9, 0xBC, 0xEF, 0xD6, 0x2E, 0x8B, 0xE1, 0x7F, 0x68, 0x50,
		0x7B, 0x72, 0xC0, 0x6D, 0x60, 0x4B, 0xED, 0xAF, 0xCB, 0x1D, 0x70, 0xEA, 0x7B, 0x05, 0xC8, 0xAA,
		0x2B, 0xA9, 0x32, 0xF2, 0x37, 0x1D, 0xD2, 0x88, 0x26, 0x55, 0x0A, 0xE2, 0x08, 0x06, 0xC9, 0x8B,
		0xD1, 0x34, 0x32, 0x33, 0xBF, 0xB4, 0xC8, 0x91, 0xFC, 0x8E, 0x49, 0x43, 0x0B, 0x61, 0x4C, 0x81,
		0xBC, 0x72, 0x40, 0x27, 0xCE, 0xFA, 0xA6, 0x82, 0x11, 0x20, 0x69, 0x20, 0x94, 0x87, 0x38, 0xAF,
		0x9A, 0x86, 0xC7, 0x74, 0xCA, 0x5C, 0xD2, 0x49, 0x7D, 0x29, 0x22, 0x7B, 0x99, 0x02, 0xD5, 0x3A,
		0x1E, 0xF7, 0xDA, 0x74, 0xDE, 0x90, 0xE0, 0xCA, 0x75, 0x69, 0xEF, 0xA9, 0x56, 0x6C, 0xDC, 0x18,
		0x25, 0x1B, 0x63, 0x9E, 0xA0, 0x14, 0xE4, 0x7D, 0xA1, 0xE4, 0x04, 0x33, 0x5C, 0xE5, 0xFA, 0xB3,
		0x42, 0xD0, 0x0C, 0xD2, 0x97, 0xCC, 0x85, 0x31, 0xD0, 0x0B, 0x80, 0xA4, 0x32, 0x73, 0x75, 0x0F,
		0x04, 0xF9, 0xA0, 0xE0, 0x90, 0x4E, 0xE7, 0x7B, 0xFA, 0xCE, 0x9E, 0x9B, 0xEE, 0xE5, 0xB6, 0x0D,
		0xD4, 0xA6, 0x9F, 0xD3, 0xD4, 0xB0, 0xE2, 0x47, 0x5E, 0x12, 0x47, 0xCF, 0xF6, 0xA4, 0xF5, 0x67,
		0xF7, 0xE0, 0x63, 0x62, 0xF0, 0xEF, 0x62, 0x2E, 0x5D, 0x59, 0x77, 0x2D, 0xE4, 0xF5, 0x1E, 0x8B,
		0x72, 0xC1, 0x15, 0x2A, 0x16, 0xE3, 0x42, 0xC8, 0xF7, 0xB2, 0x6F, 0xCB, 0x82, 0x70, 0x08, 0x3A,
		0xAC, 0xDD, 0x0A, 0x0C, 0xAE, 0x12, 0x70, 0xBB, 0xDF, 0x66, 0xAC, 0x26, 0xD2, 0x31, 0x6C, 0xFA,
		0x13, 0xD3, 0xCC, 0xB7, 0x9E, 0xDC, 0xC3, 0x91, 0x95, 0xA3, 0x12, 0x45, 0x71, 0x51, 0x89, 0x8B,
		0x34, 0x32, 0x64, 0x95, 0x4C, 0xD9, 0x35, 0x42, 0xA3, 0x99, 0xB2, 0x4A, 0x9E, 0x12, 0xC9, 0xF6 };

unsigned char key[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

int main() {
	// Printing the address of the shellcode
	printf("[i] shellcode : 0x%p \n", EncShellcode);
	printf("[#] Press <Enter> To Decrypt ...");
	getchar();

	// Allocating buffer to hold decrypted shellcode
	PBYTE DecryptedShellcode = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(EncShellcode));
	if (DecryptedShellcode)
		memcpy(DecryptedShellcode, EncShellcode, sizeof(EncShellcode));

	// Decryption
	if (!Rc4EncryptionViSystemFunc032(key, DecryptedShellcode, sizeof(key), sizeof(EncShellcode))) {
		// Failed
		return -1;
	}

	// Printing the decrypted buffer
	PrintHexData("Shellcode", DecryptedShellcode, sizeof(EncShellcode));

	// Freeing the allocated buffer
	HeapFree(GetProcessHeap(), 0, DecryptedShellcode);

	// Exit
	printf("[#] Press <Enter> To Quit ...");
	getchar();
	return 0;

}
